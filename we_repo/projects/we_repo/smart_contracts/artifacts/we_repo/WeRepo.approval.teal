#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "_p" 0x151f7c75 "total_projects" 0x0000000000000000
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txn NumAppArgs
    bz main_after_if_else@15
    pushbytess 0xb8447b36 0xb6113dc7 0xf83918ba 0x8246c525 0x2557f664 0xea638972 0xe9894450 0x8dc0b23e 0x1d77c9f1 // method "createApplication()void", method "createNewProject(string)void", method "updateProjectName(string)void", method "createProjectMicroDapp(uint64,uint64)void", method "getProjectName()string", method "getDappIdByType(uint64)uint64", method "getAllDappIds()uint64[]", method "getProjectHoldersDao()uint64", method "getProjectRewardsDao()uint64"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_createNewProject_route@4 main_updateProjectName_route@5 main_createProjectMicroDapp_route@6 main_getProjectName_route@7 main_getDappIdByType_route@8 main_getAllDappIds_route@9 main_getProjectHoldersDao_route@10 main_getProjectRewardsDao_route@11

main_after_if_else@15:
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    intc_0 // 0
    return

main_getProjectRewardsDao_route@11:
    // smart_contracts/we_repo/contract.algo.ts:129
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getProjectRewardsDao
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getProjectHoldersDao_route@10:
    // smart_contracts/we_repo/contract.algo.ts:122
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getProjectHoldersDao
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getAllDappIds_route@9:
    // smart_contracts/we_repo/contract.algo.ts:115
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getAllDappIds
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getDappIdByType_route@8:
    // smart_contracts/we_repo/contract.algo.ts:102
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/we_repo/contract.algo.ts:102
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    callsub getDappIdByType
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getProjectName_route@7:
    // smart_contracts/we_repo/contract.algo.ts:96
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getProjectName
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createProjectMicroDapp_route@6:
    // smart_contracts/we_repo/contract.algo.ts:66
    // @abimethod({ allowActions: 'NoOp' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/we_repo/contract.algo.ts:66
    // @abimethod({ allowActions: 'NoOp' })
    callsub createProjectMicroDapp
    intc_1 // 1
    return

main_updateProjectName_route@5:
    // smart_contracts/we_repo/contract.algo.ts:58
    // @abimethod({ allowActions: 'NoOp' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/we_repo/contract.algo.ts:58
    // @abimethod({ allowActions: 'NoOp' })
    callsub updateProjectName
    intc_1 // 1
    return

main_createNewProject_route@4:
    // smart_contracts/we_repo/contract.algo.ts:37
    // @abimethod({ allowActions: 'NoOp' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/we_repo/contract.algo.ts:37
    // @abimethod({ allowActions: 'NoOp' })
    callsub createNewProject
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/we_repo/contract.algo.ts:27
    // @abimethod({ onCreate: 'require', allowActions: 'NoOp' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/we_repo/contract.algo.ts::WeRepo.createApplication() -> void:
createApplication:
    // smart_contracts/we_repo/contract.algo.ts:19
    // manager_address = GlobalState<Account>()
    pushbytes "manager_address"
    // smart_contracts/we_repo/contract.algo.ts:30
    // this.manager_address.value = Txn.sender
    txn Sender
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_projects = GlobalState<uint64>()
    bytec_2 // "total_projects"
    // smart_contracts/we_repo/contract.algo.ts:33
    // this.total_projects.value = 0
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.createNewProject(project_name: bytes) -> void:
createNewProject:
    // smart_contracts/we_repo/contract.algo.ts:37-38
    // @abimethod({ allowActions: 'NoOp' })
    // public createNewProject(project_name: string): void {
    proto 1 0
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:40
    // if (!this.project(Txn.sender).exists) {
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:40
    // if (!this.project(Txn.sender).exists) {
    box_len
    bury 1
    bnz createNewProject_else_body@2
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:42
    // this.project(Txn.sender).create({ size: 500 })
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:42
    // this.project(Txn.sender).create({ size: 500 })
    pushint 500 // 500
    box_create
    pop
    // smart_contracts/we_repo/contract.algo.ts:47
    // project_name_des: new arc4.Str(project_name),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/we_repo/contract.algo.ts:45-48
    // this.project(Txn.sender).value = new ProjectData({
    //   dappIds: new arc4.DynamicArray<arc4.UintN64>(),
    //   project_name_des: new arc4.Str(project_name),
    // })
    pushbytes 0x000400060000
    swap
    concat
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:45
    // this.project(Txn.sender).value = new ProjectData({
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:45-48
    // this.project(Txn.sender).value = new ProjectData({
    //   dappIds: new arc4.DynamicArray<arc4.UintN64>(),
    //   project_name_des: new arc4.Str(project_name),
    // })
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_projects = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "total_projects"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/we_repo/contract.algo.ts:51
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    intc_1 // 1
    +
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_projects = GlobalState<uint64>()
    bytec_2 // "total_projects"
    // smart_contracts/we_repo/contract.algo.ts:51
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    swap
    app_global_put
    retsub

createNewProject_else_body@2:
    // smart_contracts/we_repo/contract.algo.ts:54
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(project_name)
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:54
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(project_name)
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:54
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(project_name)
    dup
    box_get
    assert // Box must have value
    dup
    intc_2 // 2
    extract_uint16
    intc_0 // 0
    swap
    extract3
    uncover 2
    concat
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.updateProjectName(new_project_name: bytes) -> void:
updateProjectName:
    // smart_contracts/we_repo/contract.algo.ts:58-59
    // @abimethod({ allowActions: 'NoOp' })
    // public updateProjectName(new_project_name: string): void {
    proto 1 0
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:61
    // assert(this.project(Txn.sender).exists, 'Project created by the given address does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:61
    // assert(this.project(Txn.sender).exists, 'Project created by the given address does not exist')
    box_len
    bury 1
    assert // Project created by the given address does not exist
    // smart_contracts/we_repo/contract.algo.ts:63
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(new_project_name)
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:63
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(new_project_name)
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:63
    // this.project(Txn.sender).value.project_name_des = new arc4.Str(new_project_name)
    dup
    box_get
    assert // Box must have value
    dup
    intc_2 // 2
    extract_uint16
    intc_0 // 0
    swap
    extract3
    uncover 2
    concat
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.createProjectMicroDapp(dappId: uint64, type: uint64) -> void:
createProjectMicroDapp:
    // smart_contracts/we_repo/contract.algo.ts:66-67
    // @abimethod({ allowActions: 'NoOp' })
    // public createProjectMicroDapp(dappId: uint64, type: uint64): void {
    proto 2 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:69
    // if (!this.project(Txn.sender).exists) {
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:69
    // if (!this.project(Txn.sender).exists) {
    box_len
    bury 1
    bnz createProjectMicroDapp_after_if_else@2
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:71
    // this.project(Txn.sender).create({ size: 500 })
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:71
    // this.project(Txn.sender).create({ size: 500 })
    pushint 500 // 500
    box_create
    pop
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:72
    // this.project(Txn.sender).value = new ProjectData({
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:72-75
    // this.project(Txn.sender).value = new ProjectData({
    //   project_name_des: new arc4.Str(''),
    //   dappIds: new arc4.DynamicArray<arc4.UintN64>(),
    // })
    dup
    box_del
    pop
    pushbytes 0x0004000600000000
    box_put
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_projects = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "total_projects"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/we_repo/contract.algo.ts:78
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    intc_1 // 1
    +
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_projects = GlobalState<uint64>()
    bytec_2 // "total_projects"
    // smart_contracts/we_repo/contract.algo.ts:78
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    swap
    app_global_put

createProjectMicroDapp_after_if_else@2:
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:82
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:82
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    substring3
    frame_bury 0

createProjectMicroDapp_while_top@3:
    // smart_contracts/we_repo/contract.algo.ts:85
    // while (dappIds.length < type) {
    frame_dig 0
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 1
    frame_dig -1
    <
    // smart_contracts/we_repo/contract.algo.ts:85-87
    // while (dappIds.length < type) {
    //   dappIds.push(new arc4.UintN64(0))
    // }
    bz createProjectMicroDapp_after_while@5
    // smart_contracts/we_repo/contract.algo.ts:86
    // dappIds.push(new arc4.UintN64(0))
    frame_dig 0
    extract 2 0
    bytec_3 // 0x0000000000000000
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    b createProjectMicroDapp_while_top@3

createProjectMicroDapp_after_while@5:
    // smart_contracts/we_repo/contract.algo.ts:90
    // dappIds[type - 1] = new arc4.UintN64(dappId)
    frame_dig -2
    itob
    frame_dig -1
    intc_1 // 1
    -
    dup
    frame_dig 1
    <
    assert // Index access is out of bounds
    intc_3 // 8
    *
    intc_2 // 2
    +
    frame_dig 0
    swap
    uncover 2
    replace3
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:93
    // this.project(Txn.sender).value.dappIds = dappIds.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:93
    // this.project(Txn.sender).value.dappIds = dappIds.copy()
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    dig 2
    extract3
    dig 2
    intc_2 // 2
    extract_uint16
    dig 3
    len
    uncover 4
    dig 2
    uncover 2
    substring3
    uncover 2
    dig 5
    concat
    swap
    concat
    swap
    uncover 2
    -
    uncover 3
    len
    dig 2
    intc_2 // 2
    extract_uint16
    +
    swap
    -
    itob
    extract 6 2
    replace2 2
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.getProjectName() -> bytes:
getProjectName:
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:98
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:98
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    box_len
    bury 1
    assert // Project does not exist
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:99
    // return this.project(Txn.sender).value.project_name_des.native
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:99
    // return this.project(Txn.sender).value.project_name_des.native
    box_get
    assert // Box must have value
    dup
    intc_2 // 2
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.getDappIdByType(type: uint64) -> uint64:
getDappIdByType:
    // smart_contracts/we_repo/contract.algo.ts:102-103
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    // public getDappIdByType(type: uint64): uint64 {
    proto 1 1
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:104
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:104
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    box_len
    bury 1
    assert // Project does not exist
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:105
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:105
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    substring3
    // smart_contracts/we_repo/contract.algo.ts:108
    // if (type <= 0 || type > dappIds.length) {
    frame_dig -1
    intc_0 // 0
    <=
    bnz getDappIdByType_if_body@2
    frame_dig 0
    intc_0 // 0
    extract_uint16
    frame_dig -1
    <
    bz getDappIdByType_after_if_else@3

getDappIdByType_if_body@2:
    // smart_contracts/we_repo/contract.algo.ts:109
    // return 0
    intc_0 // 0
    swap
    retsub

getDappIdByType_after_if_else@3:
    // smart_contracts/we_repo/contract.algo.ts:112
    // return dappIds[type - 1].native
    frame_dig -1
    intc_1 // 1
    -
    frame_dig 0
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    swap
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.getAllDappIds() -> bytes:
getAllDappIds:
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:117
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:117
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    box_len
    bury 1
    assert // Project does not exist
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:118
    // return this.project(Txn.sender).value.dappIds
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:118
    // return this.project(Txn.sender).value.dappIds
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    substring3
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.getProjectHoldersDao() -> bytes:
getProjectHoldersDao:
    // smart_contracts/we_repo/contract.algo.ts:122-123
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    // public getProjectHoldersDao(): arc4.UintN64 {
    proto 0 1
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:124
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:124
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    box_len
    bury 1
    assert // Project does not exist
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:125
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:125
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    substring3
    dup
    // smart_contracts/we_repo/contract.algo.ts:126
    // return dappIds.length >= 1 ? dappIds[0] : new arc4.UintN64(0)
    intc_0 // 0
    extract_uint16
    bz getProjectHoldersDao_ternary_false@2
    frame_dig 0
    extract 2 8

getProjectHoldersDao_ternary_merge@3:
    // smart_contracts/we_repo/contract.algo.ts:126
    // return dappIds.length >= 1 ? dappIds[0] : new arc4.UintN64(0)
    swap
    retsub

getProjectHoldersDao_ternary_false@2:
    // smart_contracts/we_repo/contract.algo.ts:126
    // return dappIds.length >= 1 ? dappIds[0] : new arc4.UintN64(0)
    bytec_3 // 0x0000000000000000
    b getProjectHoldersDao_ternary_merge@3


// smart_contracts/we_repo/contract.algo.ts::WeRepo.getProjectRewardsDao() -> bytes:
getProjectRewardsDao:
    // smart_contracts/we_repo/contract.algo.ts:129-130
    // @abimethod({ allowActions: 'NoOp', readonly: true })
    // public getProjectRewardsDao(): arc4.UintN64 {
    proto 0 1
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:131
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:131
    // assert(this.project(Txn.sender).exists, 'Project does not exist')
    box_len
    bury 1
    assert // Project does not exist
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    bytec_0 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:132
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectId, ProjectData>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:132
    // const dappIds = this.project(Txn.sender).value.dappIds.copy()
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    substring3
    dup
    // smart_contracts/we_repo/contract.algo.ts:133
    // return dappIds.length >= 2 ? dappIds[1] : new arc4.UintN64(0)
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    >=
    bz getProjectRewardsDao_ternary_false@2
    frame_dig 0
    extract 10 8

getProjectRewardsDao_ternary_merge@3:
    // smart_contracts/we_repo/contract.algo.ts:133
    // return dappIds.length >= 2 ? dappIds[1] : new arc4.UintN64(0)
    swap
    retsub

getProjectRewardsDao_ternary_false@2:
    // smart_contracts/we_repo/contract.algo.ts:133
    // return dappIds.length >= 2 ? dappIds[1] : new arc4.UintN64(0)
    bytec_3 // 0x0000000000000000
    b getProjectRewardsDao_ternary_merge@3
